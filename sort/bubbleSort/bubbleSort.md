# 冒泡排序 Bubble Sort

## （一）思路分析

假设使用冒泡排序对一个有 `n` 个元素的数组进行升序排序：

* 每次冒泡过程中，仅比较**相邻的两个**元素
* 相邻元素如果不满足大小关系就**位置互换**
* 一次冒泡至少会筛出 1 个最大元素，置换到数组右侧，重复 `n` 次，就完成了 `n` 个元素的排序

### 一次冒泡的过程

以数组 `[8, 2, 3, 3, 2, 6]` 为例，升序排列，我详解下第一次冒泡过程：

8 和 2 比较，2 更小，所以互换位置，如图：

互换后，继续 8 和 3 比较，3 更小，互换位置，如图：

以此类推，我把整个这次冒泡过程列了出来：

```
[8, 2, 3, 3, 2, 6]，8 和 2 比较，互换：

[2, 8, 3, 3, 2, 6]，8 和 3 比较，互换：

[2, 3, 8, 3, 2, 6]，8 和 3 比较，互换：

[2, 3, 3, 8, 2, 6]，8 和 2 比较，互换：

[2, 3, 3, 2, 8, 6]，8 和 6 比较，互换：

[2, 3, 3, 2, 6, 8]
```

之所以叫“冒泡”，是因为**在一次冒泡过程中，经过依次相邻元素比较、交换，至少有 1 个元素会移动到它排序后应该在的位置**，从而“冒出水面”

不断冒泡，直到所有元素排列完毕

### 冒泡过程优化

理论上，对于有 `n` 个元素的数组，经过 `n` 次冒泡，一定就排好序了。但是，这个过程中还可以再优化吗？

试想，如果某次冒泡过程中，依次比较相邻元素，结果没有任何元素交换，那么即便此时没有冒泡 `n` 次，也可以终止后续的冒泡了，因为这时候数组已经完全有序

在编码中，冒泡前可以设一个 Flag 变量 `isSwap` 初始为 `false`，它标识着即将进行的冒泡过程中是否发生了元素交换。冒泡中：

* 如果发生了元素交换，`isSwap = true`
* 如果没发生元素交换，不改变 `isSwap` 值

冒泡后判断，如果 `isSwap` 仍旧为 `false`，那么就可以提前终止冒泡了，排序已完成

## （二）编码实现

```js
/**
 * @description 冒泡排序，升序，会改变原数组
 * @param {array} arr 数字数组
 */
function bubbleSort(arr) {
  if (!Array.isArray(arr) || arr.length <= 1) return arr;

  const len = arr.length;

  // 对于有 len 个元素的数组，冒泡 len 次一定可以完成排序
  for (let i = 0; i < len; i++) {
    let isSwap = false; // 冒泡过程中是否发生数据交换
    let j = 0;

    // 为什么循环终止条件是 j < len - i - 1?
    // - i: 每次冒泡至少会筛出一个最大的元素到数组右侧，这些筛出的元素不用再比较了，它们一定不比本轮冒泡的元素小
    // - 1: 冒泡过程中每次比较的是索引为 j 和 j + 1 的元素
    while (j < len - i - 1) {
      const lNum = arr[j];
      const rNum = arr[j+1];

      // 若前一个元素 > 后一个元素，交换位置
      if (lNum > rNum) {
        // 这里假设数组元素都是数字，因为是基本数据类型，所以就直接变量赋值了
        arr[j] = rNum;
        arr[j+1] = lNum;
        isSwap = true; // 本次冒泡发生了交换
      }
      j++;
    }

    // 若本次冒泡过程中无数据交换，说明已完全有序
    if (!isSwap) return arr;
  }
  return arr;
}

console.log(bubbleSort([8, 2, 3, 3, 2, 6])); // [ 2, 2, 3, 3, 6, 8 ]
```

## （三）算法分析

### 时间复杂度 & 空间复杂度

冒泡排序的时间复杂度：

* 最好情况时间复杂度：`O(n)`。待排序数组天然有序，进行 1 次冒泡后无交换，排序完成
* 最坏情况时间复杂度：`O(n^2)`。待排数组逆序，需要完整地进行 `n` 次冒泡才排序完成
* 平均时间复杂度：`O(n^2)`

冒泡排序的空间复杂度：`O(1)`。算法过程中仅使用了常量级的一些临时变量，没有其他额外的空间开销

因为空间复杂度是 `O(1)`，所以**冒泡排序是原地排序算法**

### 稳定性

在冒泡过程中，如果前后两个元素大小相同，那么不会发生位置交换。所以，**冒泡排序是稳定排序算法**

## （四）小结

算法 | 时间复杂度 | 空间复杂度 | 是否稳定
-- | -- | -- | --
冒泡排序 | `O(n^2)` | `O(1)` | 稳定
