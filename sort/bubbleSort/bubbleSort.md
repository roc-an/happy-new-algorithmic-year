# 冒泡排序 Bubble Sort

## （一）思路分析

假设使用冒泡排序对一个有 `n` 个元素的数组进行升序排序：

* 每次冒泡过程中，仅比较**相邻的两个**元素
* 相邻元素如果不满足大小关系就**位置互换**
* 一次冒泡至少会筛出 1 个最大元素，置换到数组右侧，重复 `n` 次，就完成了 `n` 个元素的排序

### 一次冒泡的过程

以数组 `[8, 2, 3, 3, 2, 6]` 为例，升序排列，我详解下第一次冒泡过程：

8 和 2 比较，2 更小，所以互换位置，如图：

互换后，继续 8 和 3 比较，3 更小，互换位置，如图：

以此类推，我把整个这次冒泡过程列了出来：

```
[8, 2, 3, 3, 2, 6]，8 和 2 比较，互换：

[2, 8, 3, 3, 2, 6]，8 和 3 比较，互换：

[2, 3, 8, 3, 2, 6]，8 和 3 比较，互换：

[2, 3, 3, 8, 2, 6]，8 和 2 比较，互换：

[2, 3, 3, 2, 8, 6]，8 和 6 比较，互换：

[2, 3, 3, 2, 6, 8]
```

之所以叫“冒泡”，是因为**在一次冒泡过程中，经过依次相邻元素比较、交换，至少有 1 个元素会移动到它排序后应该在的位置**，从而“冒出水面”

不断冒泡，直到所有元素排列完毕

### 冒泡过程优化

理论上，对于有 `n` 个元素的数组，经过 `n` 次冒泡，一定就排好序了。但是，这个过程中还可以再优化吗？

试想，如果某次冒泡过程中，依次比较相邻元素，结果没有任何元素交换，那么即便此时没有冒泡 `n` 次，也可以终止后续的冒泡了，因为这时候数组已经完全有序

在编码中，冒泡前可以设一个 Flag 变量 `isSwap` 初始为 `false`，它标识着即将进行的冒泡过程中是否发生了元素交换。冒泡中：

* 如果发生了元素交换，`isSwap = true`
* 如果没发生元素交换，不改变 `isSwap` 值

冒泡后判断，如果 `isSwap` 仍旧为 `false`，那么就可以提前终止冒泡了，排序已完成
