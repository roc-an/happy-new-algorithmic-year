# 全排列

## （一）题目描述

给定一个不含重复数字的数组 `nums`，返回其**所有可能的全排列**。你可以**按任意顺序**返回答案

示例 1：

```
输入：nums = [1, 2, 3]
输出：[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]
```

示例 2：

```
输入：nums = [0, 1]
输出：[[0, 1], [1, 0]]
```

示例 3：

```
输入：nums = [1]
输出：[[1]]
```

## （二）思路解析 - 递归回溯法

### 将全排列问题画成一棵“树”

以 `nums` 为 `[1, 2, 3]` 为例，进行排列的第 1 个数，有 3 种情况，分别是 1、2、3

如果第 1 个数是 1，那么有 2 种排列方式：

```
[1, 2, 3]
[1, 3, 2]
```

如果第 1 个数是 2：

```
[2, 1, 3]
[2, 3, 1]
```
如果第 1 个数是 3：

```
[3, 1, 2]
[3, 2, 1]
```

总共有 6 种排列情况。总之，为每个排列位置枚举不同的数字，之前已选择的数字不能再出现

如果用「树」来表示全排列的情况，如图：


### 递归与回溯

如何组织代码来逐步完成这棵树的执行呢？

我画出了分支 `[1, 2, 3]` 和 `[1, 3, 2]` 的详细执行步骤：

1. 初始路径数组为空 `[]`，枚举选择第 1 个数是 1
2. 因为 1 已经被选了，还剩 2、3，枚举选择 2
3. 1、2 都被选了，只剩下 3 了，选择 3。这时路径数组 `length` 为 3，意味着已经走了 3 步，刚好等于输入数组的长度，那么将 `[1, 2, 3]` `push` 进结果数组
4. 开始回溯，取消刚刚选择的 3。取消后剩余未选择的只有 3，而 3 已经枚举过了，那只能继续回溯
5. 继续回溯，取消选择的 2。取消后未选择的是 2、3，但是 2 已枚举过了，那可以继续枚举 3
6. 枚举选择 3，路径数组为 `[1, 3]`
7. 枚举选择 2，路径数组为 `[1, 3, 2]`，又走到头了，回溯
8. 回溯，取消选择 2
9. 回溯，取消选择 3。注意，这时 1、2、3 都已经枚举过了，只能继续回溯
10. 回溯，取消选择 1，路径数组又成空了 `[]`。这回该第 1 个数是 2 了，继续递归后续分支...

等到所有的递归、回溯都完成后，也就得到最终的全排列结果数组了

整体来看，这种思路是先遍历完树的 1 个分支，然后回溯，接着遍历完第 2 个分支，以此类推。这种遍历方式属于树的**深度优先遍历**
