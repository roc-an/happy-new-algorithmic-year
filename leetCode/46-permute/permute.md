# 全排列

## （一）题目描述

给定一个不含重复数字的数组 `nums`，返回其**所有可能的全排列**。你可以**按任意顺序**返回答案

示例 1：

```
输入：nums = [1, 2, 3]
输出：[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]
```

示例 2：

```
输入：nums = [0, 1]
输出：[[0, 1], [1, 0]]
```

示例 3：

```
输入：nums = [1]
输出：[[1]]
```

## （二）思路解析 - 递归回溯法

### 将全排列问题画成一棵“树”

以 `nums` 为 `[1, 2, 3]` 为例，进行排列的第 1 个数，有 3 种情况，分别是 1、2、3

如果第 1 个数是 1，那么有 2 种排列方式：

```
[1, 2, 3]
[1, 3, 2]
```

如果第 1 个数是 2：

```
[2, 1, 3]
[2, 3, 1]
```
如果第 1 个数是 3：

```
[3, 1, 2]
[3, 2, 1]
```

总共有 6 种排列情况。总之，为每个排列位置枚举不同的数字，之前已选择的数字不能再出现

如果用「树」来表示全排列的情况，如图：


### 递归与回溯

如何组织代码来逐步完成这棵树的执行呢？

我画出了分支 `[1, 2, 3]` 和 `[1, 3, 2]` 的详细执行步骤：

1. 初始路径数组为空 `[]`，枚举选择第 1 个数是 1
2. 因为 1 已经被选了，还剩 2、3，枚举选择 2
3. 1、2 都被选了，只剩下 3 了，选择 3。这时路径数组 `length` 为 3，意味着已经走了 3 步，刚好等于输入数组的长度，那么将 `[1, 2, 3]` `push` 进结果数组
4. 开始回溯，取消刚刚选择的 3。取消后剩余未选择的只有 3，而 3 已经枚举过了，那只能继续回溯
5. 继续回溯，取消选择的 2。取消后未选择的是 2、3，但是 2 已枚举过了，那可以继续枚举 3
6. 枚举选择 3，路径数组为 `[1, 3]`
7. 枚举选择 2，路径数组为 `[1, 3, 2]`，又走到头了，回溯
8. 回溯，取消选择 2
9. 回溯，取消选择 3。注意，这时 1、2、3 都已经枚举过了，只能继续回溯
10. 回溯，取消选择 1，路径数组又成空了 `[]`。这回该第 1 个数是 2 了，继续递归后续分支...

等到所有的递归、回溯都完成后，也就得到最终的全排列结果数组了

整体来看，这种思路是先遍历完树的 1 个分支，然后回溯，接着遍历完第 2 个分支，以此类推。这种遍历方式属于树的**深度优先遍历**

## （三）编码实现

```js
/**
 * @description 全排列
 * @param {number[]} nums
 * @return {number[][]}
 */
function permute(nums) {
  if (!Array.isArray(nums) || nums.length < 2) return [nums];

  const len = nums.length;
  const dist = []; // 结果数组
  const path = []; // 遍历路径
  const used = new Array(len); // 输入数组中，对应索引的数是否被选择

  /**
   * 深度优先遍历
   * @param {number[]} nums 输入数组
   * @param {number} depth 递归的层数，即当前已选择了几个数
   * @param {number[]} path 从根节点到任意节点的路径
   * @param {boolean[]} used 输入数组中，对应索引的数是否被选择
   * @param {number[][]} dist 整个 permute 算法输出的全排列数组
   */
  const dps = (nums, depth, path, used, dist) => {
    // 当递归层数达到输入数组的元素个数时，当前路径下所有数字已选择完毕，终止递归
    if (depth === len) {
      // 注意：整个算法 path 变量存的始终都是数组地址，所以在 push 结果数组时要进行拷贝
      dist.push([...path]);
      return;
    }

    // 循环输入数组，使用未选择的数，继续路径
    // Tips：在递归函数中，通过循环产生分支
    for (let i = 0; i < len; i++) {
      if (used[i]) {
        continue;
      }

      used[i] = true; // 将数标记为已选择
      path.push(nums[i]); // 将数记录至路径

      // 继续递归选择
      dps(nums, depth + 1, path, used, dist);

      // 回溯：撤销之前的选择操作
      used[i] = false;
      path.pop();
    }
  }

  dps(nums, 0, [], used, dist);
  return dist;
}

console.log(permute([1, 2, 3]));
// [
//   [ 1, 2, 3 ],
//   [ 1, 3, 2 ],
//   [ 2, 1, 3 ],
//   [ 2, 3, 1 ],
//   [ 3, 1, 2 ],
//   [ 3, 2, 1 ]
// ]
```

### 编码实现分析

递归与回溯的过程中，维护了几个重要的变量：

* `depth`：递归的层数，即当前已选择了几个数。当它等于输入数组长度时，意味着一个排列诞生了，于是立刻将排列 `push` 进结果数组 `dist`，这作为了终止递归的条件
* `path`：遍历路径数组。是一个栈，递归、回溯的过程中不断地将选择的数入栈，将取消选择的数出栈
* `used`：记录每个数的是否被选择状态。索引与输入数组 `nums` 一致。有了它，就能知道接下来该枚举选择谁。是一种空间换时间的设计思路

这些变量体现着当前正在进行的递归/回溯的状态，也叫**状态变量**

另外值得注意的是“递归选择”和“回溯”的操作

递归选择操作：

```js
used[i] = true; // 将数标记为已选择
path.push(nums[i]); // 将数记录至路径

// 继续递归选择
dps(nums, depth + 1, path, used, dist);
```

回溯操作：

```js
// 回溯：撤销之前的选择操作
used[i] = false;
path.pop();
```

可以发现，**回溯操作与递归选择操作中，对状态变量的修改，正好是相反的**，说白了，递归时怎么操作的，回溯时就得“逆着来”

## （四）算法分析

### 时间复杂度分析

递归回溯算法的时间复杂度，主要由节点个数决定。对于这个全排列算法，非叶子节点/叶子节点做的操作不同

* 对于非叶子节点：
  * 每个非叶子节点要进行循环，通过循环产生分支。循环次数与数据规模 `n` 成正比
  * 整棵树一共有多少个非叶子节点？精确计算的话要对每层的非叶子节点求和，当然可以通过数学公式去推导，但通过观察树也能总结出来，非叶子节点个数的量级是 `n!`
  * 非叶子节点的时间复杂度 = 每个非叶子节点循环次数 * 非叶子节点数。非叶子节点时间复杂度为 `O(n * n!)`
* 对于叶子节点：
  * 每个叶子节点意味着递归到当前路径的尽头，要拷贝 `path` 数组，然后 `push` 进结果数组。拷贝数组的时间复杂度为 `n`
  * 整棵树一共有多少个叶子节点？一共有 `n!` 个叶子节点
  * 叶子节点的时间复杂度 = 每个叶子节点的时间复杂度 * 叶子节点数。叶子节点时间复杂度为 `O(n * n!)`

综上，**全排列递归回溯算法的时间复杂度为 `O(n * n!)`**，是一个时间复杂度非常高的指数级复杂度算法，本质上完整进行了各种情况的遍历

### 空间复杂度分析

* 全排列的排列总数，与数据规模 `n` 相关，为 `n!`
* 每个排列数组，占用的空间也与数据规模相关，为 `n`

因此，**全排列递归回溯算法的空间复杂度为 `O(n * n!)`**

## （五）小结

算法 | 时间复杂度 | 空间复杂度 | 关键技巧
-- | -- | -- | --
全排列 | `O(n * n!)` | `O(n * n!)` | 递归、回溯、深度优先遍历

相对于使用广度优先遍历，深度优先遍历的方式更节省空间，只需要维护那些贯穿递归、回溯过程中的状态变量即可
